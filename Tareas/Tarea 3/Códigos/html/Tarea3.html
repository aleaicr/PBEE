
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Tarea3</title><meta name="generator" content="MATLAB 9.12"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2022-11-11"><meta name="DC.source" content="Tarea3.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#1">Tarea 3 - Ingenier&iacute;a S&iacute;smica Avanzada</a></li><li><a href="#2">Inicializar</a></li><li><a href="#3">Inputs</a></li><li><a href="#4">Load Data</a></li><li><a href="#5">P1</a></li><li><a href="#6">P2 INTERPOLANDO</a></li><li><a href="#7">P2 SIN INTERPOLAR</a></li><li><a href="#8">P3</a></li><li><a href="#9">P4</a></li><li><a href="#10">P5</a></li><li><a href="#11">P6</a></li><li><a href="#12">P6 a Interpolaci&oacute;n lineal</a></li><li><a href="#13">P6. b Interpolaci&oacute;n loglog</a></li><li><a href="#14">P6.c Ajuste Polinomial</a></li><li><a href="#15">Comparaci&oacute;n entre polinomial 1A, 1B, 1C, 1D</a></li></ul></div><h2 id="1">Tarea 3 - Ingenier&iacute;a S&iacute;smica Avanzada</h2><p>Contreras - Sanguinetti</p><pre class="codeinput"><span class="comment">% Archivos desde IIDAP</span>
</pre><h2 id="2">Inicializar</h2><pre class="codeinput">clear <span class="string">variables</span>
close <span class="string">all</span>
clc
</pre><h2 id="3">Inputs</h2><pre class="codeinput">g = 9.81; <span class="comment">% m/s2</span>
cant_estructuras = 2;                                                       <span class="comment">% Cantidad de estructutras</span>
cant_variantes = 4;                                                         <span class="comment">% Cantidad de variantes de capacidad de cada estructura (toda estructura debe tener la misma cantidad de variantes)</span>
cant_registros = 20;                                                        <span class="comment">% Cantidad de registros para curvas IDA (ingresado a IIDAP)</span>

IM_maximo = 20; <span class="comment">% g                                                         % IM m&aacute;ximo considerado para curvas IDA</span>
n_interp = 100;                                                             <span class="comment">% Cantidad de puntos en linspace para EDP interp1 para P2</span>

ResultsFiles = [<span class="string">"est_1_A"</span>;<span class="string">"est_1_B"</span>;<span class="string">"est_1_C"</span>;<span class="string">"est_1_D"</span>;<span class="string">"est_2_A"</span>;<span class="string">"est_2_B"</span>;<span class="string">"est_2_C"</span>;<span class="string">"est_2_D"</span>];   <span class="comment">% Nombre de archivos a analizar</span>
ResultsDir = <span class="string">"IIDAP_T3"</span>;                                                    <span class="comment">% Direcci&oacute;n de carpeta donde est&aacute;n los archivos</span>
n_modelos = length(ResultsFiles);                                           <span class="comment">% N&uacute;mero total de</span>
stringEstructuras = [<span class="string">"Estructura 1"</span>; <span class="string">"Estructura 2"</span>];
Alphabet = <span class="string">'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</span>;                                    <span class="comment">% Letra para cada estructura (para la leyenda de gr&aacute;ficos)</span>
ResultsFilesString = [<span class="string">"estructura 1A"</span>;<span class="string">"estructura 1B"</span>;<span class="string">"estructura 1C"</span>;<span class="string">"estructura 1D"</span>;<span class="string">"estructura 2A"</span>;<span class="string">"estructura 2B"</span>;<span class="string">"estructura 2C"</span>;<span class="string">"estructura 2D"</span>];
Colors = [<span class="string">"#0072BD"</span>;<span class="string">"#D95319"</span>;<span class="string">"#EDB120"</span>;<span class="string">"#7E2F8E"</span>;<span class="string">"#77AC30"</span>;<span class="string">"#4DBEEE"</span>;<span class="string">"#A2142F"</span>]; <span class="comment">% hay 7 colores, si se quieren m&aacute;s, fijarlos</span>

IM_range = (0.1:0.1:7).';                                                   <span class="comment">% Cambiar 7 a 4 o menos para que no se generen  valores NaN en interpolaci&oacute;n (debe verse la forma de distrbibuci&oacute;n lognromal en el &uacute;ltimo gr&aacute;fico)</span>

sequence = zeros(cant_estructuras,cant_variantes);                          <span class="comment">% Secuencia para identificar ABCD de estructura 1 o dos viendo las columnas y filas (find())</span>
<span class="keyword">for</span> i = 1:cant_estructuras
    sequence(i,:) = (i-1)*cant_variantes + (1:1:cant_variantes);
<span class="keyword">end</span>
</pre><h2 id="4">Load Data</h2><pre class="codeinput">Data = struct();
<span class="keyword">for</span> i = 1:n_modelos
    [Data(i).EDP,Data(i).IM,Data(i).IMc,Data(i).Backbone,Data(i).nGM] = getIdaCurves_v2_mod(convertStringsToChars(ResultsDir), convertStringsToChars(ResultsFiles(i)));
<span class="keyword">end</span>

<span class="comment">% Tenemos todos los datos para cada una de las 2 estructuras 4 variantes enumeradas del 1 al 8</span>
<span class="comment">% (1,2,3,4 son est1 A,B,C,D y 5,6,7,8 son est2 A,B,C,D respectivamente)</span>
<span class="comment">% De haber una tercera estructura entonces 9,10,11,12 de est3 A,B,C,D</span>
<span class="comment">% Ej: Data(1).EDP = matriz EDP que retorna getIdaCurves_v2 para estructura 1 A</span>
</pre><h2 id="5">P1</h2><p>Graficar curvas de capacidad monot&oacute;nica de las 8 figuras (2 estructuras, 4 variantes de IMK bilineal)</p><pre class="codeinput"><span class="comment">% Para graficar se necesita dy dp dpc du; Fy Fmax Fres</span>
A = cell(cant_variantes,cant_estructuras);
<span class="keyword">for</span> i = 1:cant_estructuras
    figure
    hold <span class="string">on</span>
    <span class="keyword">for</span> j = 1:cant_variantes
        dy = Data((i-1)*cant_variantes+j).Backbone.Uy_pos0;
        dp = Data((i-1)*cant_variantes+j).Backbone.Up_pos0;
<span class="comment">%         dpc = Data((i-1)*cant_variantes+j).Backbone.Upc_pos0;</span>
        du = Data((i-1)*cant_variantes+j).Backbone.Uu_pos0;
        dres = Data((i-1)*cant_variantes+j).Backbone.Ures_pos0;
        fy = Data((i-1)*cant_variantes+j).Backbone.Fy_pos0;
        fmax = Data((i-1)*cant_variantes+j).Backbone.FmaxFy_pos0*fy;
        fres = Data((i-1)*cant_variantes+j).Backbone.FresFy_pos0*fy;
        X = [0; dy; dp; dres; du; du];
        Y = [0; fy; fmax; fres; fres; 0];
        plot(X,Y)
        A{j,i} = Alphabet(j);
    <span class="keyword">end</span>
    hold <span class="string">off</span>
    xlabel(<span class="string">'\delta [m]'</span>)
    ylabel(<span class="string">'F [kN]'</span>)
    title(<span class="string">'Backbone IMK Bilinear Model'</span>)
    legend(A{:,i})
    grid <span class="string">on</span>
<span class="keyword">end</span>
clear <span class="string">dy</span> <span class="string">dp</span> <span class="string">dpc</span> <span class="string">du</span> <span class="string">dres</span> <span class="string">fy</span> <span class="string">fmax</span> <span class="string">fres</span> <span class="string">X</span> <span class="string">Y</span>
</pre><h2 id="6">P2 INTERPOLANDO</h2><p>Graficar curvas IDA y la mediana (an&aacute;lisis entre 0.1g y 20g y l&iacute;mite de desplazamiento muy grande) comparar curvas de mediana de desplazamiento</p><pre class="codeinput">n_franjas = 200;                                                            <span class="comment">% Cantidad de franjas para interpolaci&oacute;n de IM (0.1g hasta el m&aacute;ximo del "escalamiento" del registro)</span>
<span class="keyword">for</span> i = 1:n_modelos
    <span class="comment">% Interpolaci&oacute;n</span>
    <span class="keyword">for</span> n = 1:Data(i).nGM
        EDP_rmm = rmmissing(Data(i).EDP(:,n));
        IM_rmm = rmmissing(Data(i).IM(:,n));
        Data(i).IM_interp1(:,n) = linspace(0.1,max(Data(i).IM(:,n)),n_franjas); <span class="comment">% g</span>
        Data(i).EDP_interp1(:,n) = interp1(IM_rmm,EDP_rmm,Data(i).IM_interp1(:,n),<span class="string">'linear'</span>,<span class="string">'extrap'</span>);
<span class="comment">%         Data(i).EDP_interp1(:,n) = interp1(Data(i).IM(:,n),Data(i).EDP(:,n),Data(i).IM_interp1(:,n),'linear','extrap');</span>
<span class="comment">%         Data(i).EDP_interp1_pchip(:,n) = interp1(Data(i).IM(:,n),Data(i).EDP(:,n),Data(i).IM_interp1(:,n),'pchip');</span>
    <span class="keyword">end</span>

    <span class="comment">% Distribuci&oacute;n</span>
<span class="comment">%     EDP_stdln = std(log(Data(i).EDP_interp1.'));                           % Sin dispersi&oacute;n porq no me da razonable, IDKW</span>
    Data(i).EDP_median(:,1) = geomean(Data(i).EDP_interp1.',<span class="string">'omitnan'</span>).';                  <span class="comment">% Creo que no es necesario omitnan ahora ya que interpolamos con rmmissing</span>

    <span class="comment">% Figura</span>
    figure
    plot(Data(i).EDP,Data(i).IM,<span class="string">'.-'</span>,<span class="string">'color'</span>,<span class="string">'#606060'</span>)
    hold <span class="string">on</span>
<span class="comment">%     plot(Data(i).EDP_interp1,Data(i).IM_interp1,'color','#606060');</span>
    plot(Data(i).EDP_median(:,1),Data(i).IM_interp1(:,1),<span class="string">'color'</span>,<span class="string">'r'</span>,<span class="string">'LineWidth'</span>,2)
<span class="comment">%     plot(exp(log(EDP_median.')+EDP_stdln.'),Data(i).IM_interp1(:,1),'--','color','r','LineWidth',2)</span>
<span class="comment">%     plot(exp(log(EDP_median.')-EDP_stdln.'),Data(i).IM_interp1(:,1),'--','color','r','LineWidth',2)</span>
    hold <span class="string">off</span>
    xlabel(<span class="string">'EDP: desplazamiento latereal [m]'</span>)
    ylabel(<span class="string">'IM: Sa(T_1) [g]'</span>)
    title(<span class="string">'Curvas IDA'</span>, ResultsFilesString(i))
    grid <span class="string">on</span>
    legend([<span class="string">'Curvas IDA'</span>; convertStringsToChars(repmat(string( ),Data(i).nGM-1,1));<span class="string">'Mediana'</span>])
<span class="keyword">end</span>

<span class="comment">% % Todas las medianas juntas</span>
<span class="comment">% figure</span>
<span class="comment">% plot(Data.EDP_median,Data.IM_interp1(:,1))</span>
<span class="comment">% xlabel('EDP: Desplazamiento [m]')</span>
<span class="comment">% ylabel('IM: Sa(T_1) [g]')</span>
<span class="comment">% title('Medianas')</span>

<span class="comment">% Separadas por estructura</span>
<span class="keyword">for</span> i = 1:cant_estructuras
    figure
    hold <span class="string">on</span>
    <span class="keyword">for</span> j = 1:cant_variantes
        plot(Data((i-1)*cant_variantes+j).EDP_median,Data((i-1)*cant_variantes+j).IM_interp1(:,1))
    <span class="keyword">end</span>
    hold <span class="string">off</span>
    xlabel(<span class="string">'EDP: Desplazamiento [m]'</span>)
    ylabel(<span class="string">'IM: Sa(T_1) [g]'</span>)
    title(<span class="string">'Medianas'</span>)
    legend(A{:,i})
    grid <span class="string">on</span>
<span class="keyword">end</span>
</pre><h2 id="7">P2 SIN INTERPOLAR</h2><p>for i = 1:n_ests    Data(i).EDP_median2(:,1) = geomean(Data(i).EDP.','omitnan').';                  % Creo que no es necesario omitnan ahora ya que interpolamos con rmmissing     figure     plot(Data(i).EDP,Data(i).IM,'.-','color','#606060')     hold on     plot(Data(i).EDP_median2(:,1),Data(i).IM(:,14),'color','r','LineWidth',2)     hold off     xlabel('EDP: desplazamiento latereal [m]')     ylabel('IM: Sa(T_1) [g]')     title('Curvas IDA', ResultsFilesString(i))     grid on     legend(['Curvas IDA'; convertStringsToChars(repmat(string( ),cant_registros-1,1));'Mediana']) end</p><p>for i = 1:cant_estr     figure     hold on     for j = 1:cant_variantes         plot(Data((i-1)*cant_variantes+j).EDP_median2,Data((i-1)*cant_variantes+j).IM(:,14))     end     hold off     xlabel('EDP: Desplazamiento [m]')     ylabel('IM: Sa(T_1) [g]')     title('Medianas')     legend(A{:,i})     grid on end</p><h2 id="8">P3</h2><p>Graficar las curvas de fragilidad de colapso para cada estructura</p><pre class="codeinput"><span class="keyword">for</span> i = 1:cant_estructuras     <span class="comment">% 2</span>
    <span class="comment">% Datos de curva de fragilidad de colapso</span>
    figure
    hold <span class="string">on</span>
    <span class="keyword">for</span> j = 1:cant_variantes        <span class="comment">% 4</span>
        Data((i-1)*cant_variantes+j).muln = mean(log(Data((i-1)*cant_variantes+j).IMc).');
        Data((i-1)*cant_variantes+j).stdln = std(log(Data((i-1)*cant_variantes+j).IMc).');
        Data((i-1)*cant_variantes+j).PC = normcdf((log(Data((i-1)*cant_variantes+j).IMc).'-Data((i-1)*cant_variantes+j).muln)./Data((i-1)*cant_variantes+j).stdln);
        <span class="comment">% Contar</span>
        Data((i-1)*cant_variantes+j).nj = Data(i).nGM;
        Data((i-1)*cant_variantes+j).zj = 0;
        <span class="keyword">for</span> r = 1:length(Data((i-1)*cant_variantes+j))
            <span class="keyword">for</span> p = 1:length(Data(i).IMc)
                <span class="keyword">if</span> Data(i).IMc(r,1) &gt;= max(Data(i).IM(:,p))
                    Data((i-1)*cant_variantes+j).zj = Data((i-1)*cant_variantes+j).zj + 1;
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>
        Data((i-1)*cant_variantes+j).fraccion = Data((i-1)*cant_variantes+j).zj/Data((i-1)*cant_variantes+j).nj;
        plot(Data((i-1)*cant_variantes+j).IMc,Data((i-1)*cant_variantes+j).PC,<span class="string">'o'</span>,<span class="string">'color'</span>,Colors(j))
    <span class="keyword">end</span>
    hold <span class="string">off</span>
    xlabel(<span class="string">'IM: Sa(T_1) [g]'</span>)
    ylabel(<span class="string">'P(C|IM=im)'</span>)
    legend(A{:,i})
    title(<span class="string">'Datos de Probabilidad de Colapso'</span>, stringEstructuras(i))
    grid <span class="string">on</span>

    <span class="comment">% Curva de fragilidad de colapso (lognormal)</span>
    figure
    hold <span class="string">on</span>
    <span class="keyword">for</span> j = 1:cant_variantes
        frag((i-1)*cant_variantes+j).curvFrag = logncdf(IM_range, Data((i-1)*cant_variantes+j).muln,Data((i-1)*cant_variantes+j).stdln);
        plot(IM_range,frag((i-1)*cant_variantes+j).curvFrag,<span class="string">'color'</span>,Colors(j))
    <span class="keyword">end</span>
    <span class="keyword">for</span> j = 1:cant_variantes                                                <span class="comment">% Repet&iacute; for para arreglar la leyenda</span>
        plot(Data((i-1)*cant_variantes+j).IMc,Data((i-1)*cant_variantes+j).PC,<span class="string">'o'</span>,<span class="string">'color'</span>,Colors(j))
    <span class="keyword">end</span>
    hold <span class="string">off</span>
    xlabel(<span class="string">'IM: Sa(T_1) [g]'</span>)
    ylabel(<span class="string">'P(C|IM=im)'</span>)
    legend(A{:,i})
    title(<span class="string">'Curva de Fragilidad de Colapso'</span>, stringEstructuras(i))
    grid <span class="string">on</span>
<span class="keyword">end</span>
</pre><h2 id="9">P4</h2><p>Nombre de archivos</p><pre class="codeinput">USGSdataName_est1 = <span class="string">'USGS_data_est1.xlsx'</span>;
USGSdataName_est2 = <span class="string">'USGS_data_est2.xlsx'</span>;

<span class="comment">% Importar matrices</span>
USGS_est1 = readmatrix(USGSdataName_est1);
USGS_est2 = readmatrix(USGSdataName_est2);
<span class="comment">% Como USGS_est1(end,2) = 0, lo eliminamos</span>
USGS_est1(end,:) = [];

hazard = struct();
hazard(1).IM = USGS_est1(:,1);
hazard(2).IM = USGS_est2(:,1);
hazard(1).lambda = USGS_est1(:,2);
hazard(2).lambda = USGS_est2(:,2);

<span class="comment">% Gr&aacute;ficos</span>
figure
loglog(USGS_est1(:,1),USGS_est1(:,2),<span class="string">'.-'</span>)
hold <span class="string">on</span>
loglog(USGS_est2(:,1),USGS_est2(:,2),<span class="string">'.-'</span>)
hold <span class="string">off</span>
xlabel(<span class="string">'IM: Sa(T_1) [g]'</span>)
ylabel(<span class="string">'Annual Frequency of Exceedence \lambda_c'</span>)
title(<span class="string">'Hazard Curves USGS'</span>)
legend(<span class="string">'USGS T = 3.00 [sec]'</span>,<span class="string">'USGS T = 0.20 [sec]'</span>)
grid <span class="string">on</span>

<span class="comment">% Interpolaci&oacute;n para generar m&aacute;s datos</span>
IM_length = 100;                                                            <span class="comment">% Cantidad de valores a interpolar</span>
USGSinterplog_est1(:,1) = linspace(0.0025,3.28,IM_length).';                   <span class="comment">% Mejor modificarlo a meno, si no, puede que el ajuste polinomial de Miranda salga mal</span>
USGSinterplog_est2(:,1) = linspace(0.0025,7.3,IM_length).';                   <span class="comment">% Los l&iacute;mites deben ser de la parte curva</span>

USGSinterplog_est1(:,2) = exp(interp1(log(USGS_est1(:,1)),log(USGS_est1(:,2)),log(USGSinterplog_est1(:,1))));
USGSinterplog_est2(:,2) = exp(interp1(log(USGS_est2(:,1)),log(USGS_est2(:,2)),log(USGSinterplog_est2(:,1))));

<span class="comment">% % Borrar NaN</span>
USGSinterplog_est1 = rmmissing(USGSinterplog_est1);
USGSinterplog_est2 = rmmissing(USGSinterplog_est2);

<span class="comment">% 2% en 50 a&ntilde;os</span>
lambda_2_50_annos = 1/2475;
IM_2_50_annos_est1 = interp1(USGSinterplog_est1(:,2),USGSinterplog_est1(:,1),lambda_2_50_annos);
IM_2_50_annos_est2 = interp1(USGSinterplog_est2(:,2),USGSinterplog_est2(:,1),lambda_2_50_annos);

<span class="comment">% Gr&aacute;ficos</span>
figure
loglog(USGSinterplog_est1(:,1),USGSinterplog_est1(:,2),<span class="string">'.-'</span>)
hold <span class="string">on</span>
loglog(USGSinterplog_est2(:,1),USGSinterplog_est2(:,2),<span class="string">'.-'</span>)
loglog(IM_2_50_annos_est1,lambda_2_50_annos,<span class="string">'o'</span>,<span class="string">'color'</span>,<span class="string">'r'</span>)
loglog(IM_2_50_annos_est2,lambda_2_50_annos,<span class="string">'o'</span>,<span class="string">'color'</span>,<span class="string">'r'</span>)
text(3*10^-1,10^-4,string(IM_2_50_annos_est1))
text(3,10^-4,string(IM_2_50_annos_est2))
hold <span class="string">off</span>
xlim([10^-3 10^1])
xlabel(<span class="string">'IM: Sa(T_1) [g]'</span>)
ylabel(<span class="string">'Annual Frequency of Exceedence \lambda_i_m'</span>)
title(<span class="string">'Hazard Curves USGS'</span>, <span class="string">'Interpolado'</span>)
legend(<span class="string">'USGS_Interp T = 3.00 [sec]'</span>,<span class="string">'USGS_Interp T = 0.20 [sec]'</span>,<span class="string">'2% en 50 a&ntilde;os (\lambda_I_M = 1/2475)'</span>)
grid <span class="string">on</span>

USGS = struct();
USGS(1).interpvals = USGSinterplog_est1;                                       <span class="comment">% primera columna son IM, segunda columna son lambda (MAF)</span>
USGS(2).interpvals = USGSinterplog_est2;                                       <span class="comment">% Primera columna son IM, segunda columna MAF</span>
</pre><h2 id="10">P5</h2><p>Coeficientes del ajuste polinomial</p><pre class="codeinput">[P1,~] = polyfit(log(USGSinterplog_est1(:,1)),log(USGSinterplog_est1(:,2)),4);   <span class="comment">% Busqueda de constantes del ajuste polinomial para estructura 1</span>
[P2,~] = polyfit(log(USGSinterplog_est2(:,1)),log(USGSinterplog_est2(:,2)),4);   <span class="comment">% Busqueda de constantes del ajuste polinomial para estructura 2</span>

<span class="comment">% Generaci&oacute;n de los valores debido al ajuste polinomial de cuarto orden</span>
lambda1_pf = zeros(IM_length,1);                                            <span class="comment">% Inicializar lambda del polinomio est 1 (lambda = MAF: Mean Annual Frequency)</span>
lambda2_pf = zeros(IM_length,1);                                            <span class="comment">% Inicializar almbda del polinomio est 2</span>
dldim1 = zeros(IM_length,1);                                                <span class="comment">% Inicializar derivada</span>
dldim2 = zeros(IM_length,1);                                                <span class="comment">% Inicializar derivada</span>

<span class="keyword">for</span> i = 1:IM_length
    <span class="comment">% Ajuste polinomial primera estructura</span>
    im = USGS(1).interpvals(i,1);
    lambda1_pf(i) = exp(P1(5) + P1(4)*log(im) + P1(3)*log(im)^2 + P1(2)*log(im)^3 + P1(1)*log(im)^4); <span class="comment">% Eq.3 Miranda Polinomio</span>
    parte1 = (P1(4)+2*P1(3)*log(im)+3*P1(2)*log(im)^2+4*P1(1)*log(im)^3)/im;
    dldim1(i) = abs(parte1*exp(log(lambda1_pf(i))));                        <span class="comment">% Se puede quitar exp(log(lambda)) y dejar solo lambda</span>

    <span class="comment">% Ajuste polinomial segunda estructura</span>
    im = USGS(2).interpvals(i,1);
    lambda2_pf(i) = exp(P2(5) + P2(4)*log(im) + P2(3)*log(im)^2 + P2(2)*log(im)^3 + P2(1)*log(im)^4); <span class="comment">% Eq.3 Miranda Polinomio</span>
    parte1 = (P2(4)+2*P2(3)*log(im)+3*P2(2)*log(im)^2+4*P2(1)*log(im)^3)/im;
    dldim2(i) = abs(parte1*exp(log(lambda2_pf(i))));
<span class="keyword">end</span>

<span class="comment">% Esto que escrib&iacute; lo tira al rev&eacute;s xd</span>
<span class="comment">% IM_vals = logspace(-3,0,IM_length).';                                       % Valores de IM para interpolar</span>
<span class="comment">% lambda1_pf = exp(P1(5)*ones(IM_length,1) + P1(4).*log(IM_vals) + P1(3)*log(IM_vals).^2 + P1(4)*log(IM_vals).^3 + P1(5)*log(IM_vals).^4);</span>
<span class="comment">% lambda2_pf = exp(P2(5)*ones(IM_length,1) + P2(4).*log(IM_vals) + P2(3)*log(IM_vals).^2 + P2(4)*log(IM_vals).^3 + P2(5)*log(IM_vals).^4);</span>

figure
loglog(USGS_est1(:,1),USGS_est1(:,2),<span class="string">'.-'</span>)
hold <span class="string">on</span>
loglog(USGS_est2(:,1),USGS_est2(:,2),<span class="string">'.-'</span>)
loglog(USGS(1).interpvals(:,1),lambda1_pf)
loglog(USGS(2).interpvals(:,1),lambda2_pf)
hold <span class="string">off</span>
xlabel(<span class="string">'IM: Sa(T_1) [g]'</span>)
ylabel(<span class="string">'Annual Frequency of Exceedence \lambda_im (MAF)'</span>)
title(<span class="string">'Hazard Curves USGS'</span>)
legend(<span class="string">'USGS T = 3.00 [sec]'</span>,<span class="string">'USGS T = 0.20 [sec]'</span>,<span class="string">'Polinomial Fit T = 3.00 [sec]'</span>,<span class="string">'Polyfit T = 0.20 [sec]'</span>)
grid <span class="string">on</span>

figure
loglog(USGS(1).interpvals(:,1),dldim1);
hold <span class="string">on</span>
loglog(USGS(2).interpvals(:,1),dldim2);
hold <span class="string">off</span>
xlabel(<span class="string">'IM: Sa(T_1) [g]'</span>)
ylabel(<span class="string">'Derivada lambda_im'</span>)
title(<span class="string">'Derivada De curva de Amenaza s&iacute;smica'</span>)
legend(<span class="string">'T = 3.00 [sec]'</span>, <span class="string">'T = 0.20 [Sec]'</span>)
grid <span class="string">on</span>
</pre><h2 id="11">P6</h2><p>Caluclar y graficar la desagregaci&oacute;n (por IM=im) de la tasa anual media de colapso de las estructuras 1A y 2A, considerando los siguientes casos para la deriva de la curva de amenaza s&iacute;smica</p><h2 id="12">P6 a Interpolaci&oacute;n lineal</h2><pre class="codeinput"><span class="comment">% Inputs iniciales</span>
lambda_col = zeros(n_modelos,1);                                            <span class="comment">% Lambdas de Colapso</span>
desCol = struct();                                                          <span class="comment">% Desagregaci&oacute;n del colapso</span>
mod_analizar = [1 2 3 4];                                                       <span class="comment">% N&uacute;mero del modelo que se quiere analizar (primeras variantes de cada estructura)</span>

<span class="keyword">for</span> r = 1:length(mod_analizar)                                                  <span class="comment">% Cantidad de curvas de amenaza (1 para cada estructura, 1 estructura es un periodo =&gt; dos estructuras)</span>
    j = mod_analizar(r);                                                    <span class="comment">% N&uacute;mero del modelo que quiero analizar</span>
    [i,~] = find(sequence == j);                                            <span class="comment">% Buscar qu&eacute; estructura es dependiendo del n&uacute;mero del modelo</span>
    hazard(i).IMlineal = IM_range;
    hazard(i).lambdalineal = interp1(hazard(i).IM,hazard(i).lambda,hazard(i).IMlineal);
    hazard(i).absdiff = abs(diff(hazard(i).lambdalineal)./diff(hazard(i).IMlineal));
<span class="keyword">end</span>

<span class="keyword">for</span> r = 1:numel(mod_analizar)                                               <span class="comment">% Para los modelos que quiero analizar</span>
    j = mod_analizar(r);                                                    <span class="comment">% N&uacute;mero del modelo que quiero analizar</span>
    [i,~] = find(sequence == j);                                            <span class="comment">% Buscar qu&eacute; estructura es dependiendo del n&uacute;mero del modelo</span>
    figure
    <span class="comment">% Curva de Fragilidad P(C|IM=im)</span>
    sp1 = subplot(3,1,1);
    plot(IM_range,frag(j).curvFrag,<span class="string">'color'</span>,<span class="string">'r'</span>)
    grid <span class="string">on</span>

    <span class="comment">% abs de Derivada de amenaza s&iacute;smica |dlambda_IM(IM=im)/dIM=im|</span>
    sp2 = subplot(3,1,2);
    plot(hazard(i).IMlineal, [hazard(i).absdiff; hazard(i).absdiff(end,1)]) <span class="comment">% Repito el &uacute;ltimo n&uacute;mero de la derivada para que sean 70 elementos</span>
    grid <span class="string">on</span>

    <span class="comment">% Desagregaci&oacute;n del Riesgo de Colapso P(C|IM=im)*|dlambda_IM(IM=im)/dIM=im|</span>
    sp3 = subplot(3,1,3);
    desCol(j).Desagregacion_lineal = frag(j).curvFrag.*[hazard(i).absdiff; hazard(i).absdiff(end,1)];
    plot(hazard(i).IMlineal,desCol(j).Desagregacion_lineal)
    grid <span class="string">on</span>

    <span class="comment">% Tasa anual media de colapso</span>
    lambda_col(j,1) = trapz(hazard(i).IMlineal,frag(j).curvFrag.*[hazard(i).absdiff; hazard(i).absdiff(end,1)]);
    xlabel(<span class="string">'IM = Sa(T_1)'</span>)
    ylabel(sp1,<span class="string">'P(C|IM=im)'</span>)
    ylabel(sp2,<span class="string">'|d\lambda_I_M/dIM|'</span>)
    ylabel(sp3,<span class="string">'P(C|IM=im)*|d\lambda_I_M/dIM|'</span>)
    sgtitle([<span class="string">'Desagregaci&oacute;n Tasa Anual Media de Colapso'</span>, <span class="string">'Interpolaci&oacute;n Lineal'</span>, ResultsFilesString(j)])
<span class="keyword">end</span>
</pre><h2 id="13">P6. b Interpolaci&oacute;n loglog</h2><pre class="codeinput">lambda_col_log = zeros(n_modelos,1);                                            <span class="comment">% Lambdas de Colapso</span>
<span class="keyword">for</span> r = 1:cant_estructuras
    j = mod_analizar(r);                                                    <span class="comment">% N&uacute;mero del modelo que quiero analizar</span>
    [i,~] = find(sequence == j);                                            <span class="comment">% Buscar qu&eacute; estructura es dependiendo del n&uacute;mero del modelo</span>
    hazard(i).IMlog = IM_range;
    hazard(i).lambdalog =  exp(interp1(log(hazard(i).IM),log(hazard(i).lambda),log(hazard(i).IMlog)));
    hazard(i).absdifflog = abs(diff(hazard(i).lambdalog)./diff(hazard(i).IMlog));
<span class="keyword">end</span>

<span class="keyword">for</span> r = 1:numel(mod_analizar)                                               <span class="comment">% Para los modelos que quiero analizar</span>
    j = mod_analizar(r);                                                    <span class="comment">% N&uacute;mero del modelo que quiero analizar</span>
    [i,~] = find(sequence == j);                                            <span class="comment">% Buscar qu&eacute; estructura es dependiendo del n&uacute;mero del modelo</span>
    figure
    <span class="comment">% Curva de Fragilidad P(C|IM=im)</span>
    sp1 = subplot(3,1,1);
    plot(IM_range,frag(j).curvFrag,<span class="string">'color'</span>,<span class="string">'r'</span>)
    grid <span class="string">on</span>

    <span class="comment">% abs de Derivada de amenaza s&iacute;smica |dlambda_IM(IM=im)/dIM=im|</span>
    sp2 = subplot(3,1,2);
    plot(hazard(i).IMlog, [hazard(i).absdifflog; hazard(i).absdifflog(end,1)]) <span class="comment">% Repito el &uacute;ltimo n&uacute;mero de la derivada para que sean 70 elementos</span>
    grid <span class="string">on</span>

    <span class="comment">% Desagregaci&oacute;n del Riesgo de Colapso P(C|IM=im)*|dlambda_IM(IM=im)/dIM=im|</span>
    sp3 = subplot(3,1,3);
    desCol(j).Desagregacion_log = frag(j).curvFrag.*[hazard(i).absdifflog; hazard(i).absdifflog(end,1)];
    plot(hazard(i).IMlog,desCol(j).Desagregacion_log)
    grid <span class="string">on</span>

    <span class="comment">% Tasa anual media de colapso</span>
    lambda_col_log(j,1) = trapz(hazard(i).IMlog,frag(j).curvFrag.*[hazard(i).absdifflog; hazard(i).absdifflog(end,1)]);
    xlabel(<span class="string">'IM = Sa(T_1)'</span>)
    ylabel(sp1,<span class="string">'P(C|IM=im)'</span>)
    ylabel(sp2,<span class="string">'|d\lambda_IM/dIM|'</span>)
    ylabel(sp3,<span class="string">'P(C|IM=im)*|d\lambda_IM/dIM|'</span>)
    sgtitle([<span class="string">'Desagregaci&oacute;n Tasa Anual Media de Colapso'</span>,<span class="string">'Interpolaci&oacute;n LogLog'</span>, ResultsFilesString(j)])
<span class="keyword">end</span>
</pre><h2 id="14">P6.c Ajuste Polinomial</h2><pre class="codeinput">lambda_col_poli = zeros(n_modelos,1);

<span class="comment">% [P1,~] = polyfit(log(hazard(1).IMlog),log(hazard(1).lambdalog),4);   % Busqueda de constantes del ajuste polinomial para estructura 1</span>
<span class="comment">% [P2,~] = polyfit(log(hazard(2).IMlog),log(hazard(2).lambdalog),4);   % Busqueda de constantes del ajuste polinomial para estructura 2</span>

<span class="keyword">for</span> r = 1:cant_estructuras
    j = mod_analizar(r);                                                    <span class="comment">% N&uacute;mero del modelo que quiero analizar</span>
    [i,~] = find(sequence == j);                                            <span class="comment">% Buscar qu&eacute; estructura es dependiendo del n&uacute;mero del modelo</span>
    hazard(i).IMpoli = IM_range;
    <span class="keyword">for</span> iv = 1:length(IM_range)
        im = IM_range(iv,1);
        <span class="keyword">if</span> i == 1
            P = P1;
        <span class="keyword">elseif</span> i == 2
            P = P2;
        <span class="keyword">end</span>
        hazard(i).lambdapoli(iv,1) = exp(P(5) + P(4)*log(im) + P(3)*log(im)^2 + P(2)*log(im)^3 + P(1)*log(im)^4); <span class="comment">% Eq.3 Miranda Polinomio</span>
        parte1 = (P(4) + 2*P(3)*log(im) + 3*P(2)*log(im)^2 + 4*P(1)*log(im)^3)/im;
        hazard(i).absdiffpoli(iv,1) = abs(parte1*exp(log(hazard(i).lambdapoli(iv,1))));
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">for</span> r = 1:numel(mod_analizar)                                               <span class="comment">% Para los modelos que quiero analizar</span>
    j = mod_analizar(r);                                                    <span class="comment">% N&uacute;mero del modelo que quiero analizar</span>
    [i,~] = find(sequence == j);                                            <span class="comment">% Buscar qu&eacute; estructura es dependiendo del n&uacute;mero del modelo</span>
    figure
    <span class="comment">% Curva de Fragilidad P(C|IM=im)</span>
    sp1 = subplot(3,1,1);
    plot(IM_range,frag(j).curvFrag,<span class="string">'color'</span>,<span class="string">'r'</span>)
    grid <span class="string">on</span>

    <span class="comment">% abs de Derivada de amenaza s&iacute;smica |dlambda_IM(IM=im)/dIM=im|</span>
    sp2 = subplot(3,1,2);
    plot(hazard(i).IMpoli, hazard(i).absdiffpoli)
    grid <span class="string">on</span>

    <span class="comment">% Desagregaci&oacute;n del Riesgo de Colapso P(C|IM=im)*|dlambda_IM(IM=im)/dIM=im|</span>
    sp3 = subplot(3,1,3);
    desCol(j).Desagregacion_poli = frag(j).curvFrag.*hazard(i).absdiffpoli;
    plot(hazard(i).IMpoli,desCol(j).Desagregacion_poli)
    grid <span class="string">on</span>

    <span class="comment">% Tasa anual media de colapso</span>
    lambda_col_poli(j,1) = trapz(hazard(i).IMpoli,frag(j).curvFrag.*hazard(i).absdiffpoli);
    xlabel(<span class="string">'IM = Sa(T_1)'</span>)
    ylabel(sp1,<span class="string">'P(C|IM=im)'</span>)
    ylabel(sp2,<span class="string">'|d\lambda_IM/dIM|'</span>)
    ylabel(sp3,<span class="string">'P(C|IM=im)*|d\lambda_IM/dIM|'</span>)
    sgtitle([<span class="string">'Desagregaci&oacute;n Tasa Anual Media de Colapso'</span>,<span class="string">'Ajuste polinomio cuarto orden'</span>, ResultsFilesString(j)])
<span class="keyword">end</span>


<span class="comment">% Plot ambos juntos</span>
<span class="comment">% No parametrizado, a la r&aacute;pida no mas</span>

figure
plot(hazard(1).IMlineal,desCol(1).Desagregacion_lineal)
hold <span class="string">on</span>
plot(hazard(1).IMlog, desCol(1).Desagregacion_log)
plot(hazard(1).IMlog, desCol(1).Desagregacion_poli)
hold <span class="string">off</span>
xlabel(<span class="string">'IM: Sa(T_1)'</span>)
ylabel(<span class="string">'P(C|IM=im)*|d\lambda_IM/dIM|'</span>)
title([<span class="string">'Desagregaci&oacute;n Tasa Anual Media de Colapso'</span>, ResultsFilesString(1)])
legend(<span class="string">'Interpolaci&oacute;n Lineal'</span>, <span class="string">'Interpolaci&oacute;n LogLog'</span>, <span class="string">'Ajuste Polinomial Miranda'</span>)
grid <span class="string">on</span>


figure
plot(hazard(2).IMlineal,desCol(5).Desagregacion_lineal)
hold <span class="string">on</span>
plot(hazard(2).IMlog, desCol(5).Desagregacion_log)
plot(hazard(2).IMlog, desCol(5).Desagregacion_poli)
hold <span class="string">off</span>
xlabel(<span class="string">'IM: Sa(T_1)'</span>)
ylabel(<span class="string">'P(C|IM=im)*|d\lambda_IM/dIM|'</span>)
title([<span class="string">'Desagregaci&oacute;n Tasa Anual Media de Colapso'</span>, ResultsFilesString(5)])
legend(<span class="string">'Interpolaci&oacute;n Lineal'</span>, <span class="string">'Interpolaci&oacute;n LogLog'</span>, <span class="string">'Ajuste Polinomial Miranda'</span>)
grid <span class="string">on</span>

tabla = table();
tabla.Lineal = lambda_col;
tabla.Log = lambda_col_log;
tabla.Polyfit = lambda_col_poli;
disp(tabla)
clear <span class="string">tabla</span>

<span class="comment">% Si hay alg&uacute;n valor que da NaN, disminuir el rango de IM_range en el</span>
<span class="comment">% Input, para que los &uacute;ltimos valores de la amenaza s&iacute;smica no sean tan</span>
<span class="comment">% peque&ntilde;os que la derivada se indefine.</span>
</pre><h2 id="15">Comparaci&oacute;n entre polinomial 1A, 1B, 1C, 1D</h2><pre class="codeinput">figure
plot(hazard(1).IMlog, desCol(1).Desagregacion_poli)
hold <span class="string">on</span>
plot(hazard(1).IMlog, desCol(2).Desagregacion_poli)
plot(hazard(1).IMlog, desCol(3).Desagregacion_poli)
plot(hazard(1).IMlog, desCol(4).Desagregacion_poli)
xlabel(<span class="string">'IM: Sa(T_1)'</span>)
ylabel(<span class="string">'P(C|IM=im)*|d\lambda_IM/dIM|'</span>)
title(<span class="string">'Desagregaci&oacute;n Tasa Anual Media de Colapso'</span>)
legend(<span class="string">'1A'</span>,<span class="string">'1B'</span>,<span class="string">'1C'</span>,<span class="string">'1D'</span>)
grid <span class="string">on</span>
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2022a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Tarea 3 - Ingeniería Sísmica Avanzada
% Contreras - Sanguinetti

% Archivos desde IIDAP

%% Inicializar
clear variables
close all
clc

%% Inputs
g = 9.81; % m/s2
cant_estructuras = 2;                                                       % Cantidad de estructutras
cant_variantes = 4;                                                         % Cantidad de variantes de capacidad de cada estructura (toda estructura debe tener la misma cantidad de variantes)
cant_registros = 20;                                                        % Cantidad de registros para curvas IDA (ingresado a IIDAP)

IM_maximo = 20; % g                                                         % IM máximo considerado para curvas IDA
n_interp = 100;                                                             % Cantidad de puntos en linspace para EDP interp1 para P2

ResultsFiles = ["est_1_A";"est_1_B";"est_1_C";"est_1_D";"est_2_A";"est_2_B";"est_2_C";"est_2_D"];   % Nombre de archivos a analizar
ResultsDir = "IIDAP_T3";                                                    % Dirección de carpeta donde están los archivos
n_modelos = length(ResultsFiles);                                           % Número total de 
stringEstructuras = ["Estructura 1"; "Estructura 2"];
Alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';                                    % Letra para cada estructura (para la leyenda de gráficos)
ResultsFilesString = ["estructura 1A";"estructura 1B";"estructura 1C";"estructura 1D";"estructura 2A";"estructura 2B";"estructura 2C";"estructura 2D"];
Colors = ["#0072BD";"#D95319";"#EDB120";"#7E2F8E";"#77AC30";"#4DBEEE";"#A2142F"]; % hay 7 colores, si se quieren más, fijarlos

IM_range = (0.1:0.1:7).';                                                   % Cambiar 7 a 4 o menos para que no se generen  valores NaN en interpolación (debe verse la forma de distrbibución lognromal en el último gráfico)

sequence = zeros(cant_estructuras,cant_variantes);                          % Secuencia para identificar ABCD de estructura 1 o dos viendo las columnas y filas (find())
for i = 1:cant_estructuras
    sequence(i,:) = (i-1)*cant_variantes + (1:1:cant_variantes);
end

%% Load Data
Data = struct();
for i = 1:n_modelos
    [Data(i).EDP,Data(i).IM,Data(i).IMc,Data(i).Backbone,Data(i).nGM] = getIdaCurves_v2_mod(convertStringsToChars(ResultsDir), convertStringsToChars(ResultsFiles(i)));
end

% Tenemos todos los datos para cada una de las 2 estructuras 4 variantes enumeradas del 1 al 8 
% (1,2,3,4 son est1 A,B,C,D y 5,6,7,8 son est2 A,B,C,D respectivamente)
% De haber una tercera estructura entonces 9,10,11,12 de est3 A,B,C,D
% Ej: Data(1).EDP = matriz EDP que retorna getIdaCurves_v2 para estructura 1 A

%% P1
% Graficar curvas de capacidad monotónica de las 8 figuras (2 estructuras, 4 variantes de IMK bilineal)

% Para graficar se necesita dy dp dpc du; Fy Fmax Fres
A = cell(cant_variantes,cant_estructuras);
for i = 1:cant_estructuras
    figure
    hold on
    for j = 1:cant_variantes
        dy = Data((i-1)*cant_variantes+j).Backbone.Uy_pos0;
        dp = Data((i-1)*cant_variantes+j).Backbone.Up_pos0;
%         dpc = Data((i-1)*cant_variantes+j).Backbone.Upc_pos0;
        du = Data((i-1)*cant_variantes+j).Backbone.Uu_pos0;
        dres = Data((i-1)*cant_variantes+j).Backbone.Ures_pos0;
        fy = Data((i-1)*cant_variantes+j).Backbone.Fy_pos0;
        fmax = Data((i-1)*cant_variantes+j).Backbone.FmaxFy_pos0*fy;
        fres = Data((i-1)*cant_variantes+j).Backbone.FresFy_pos0*fy; 
        X = [0; dy; dp; dres; du; du];
        Y = [0; fy; fmax; fres; fres; 0];
        plot(X,Y)
        A{j,i} = Alphabet(j);
    end
    hold off
    xlabel('\delta [m]')
    ylabel('F [kN]')
    title('Backbone IMK Bilinear Model')
    legend(A{:,i})
    grid on
end
clear dy dp dpc du dres fy fmax fres X Y

%% P2 INTERPOLANDO
% Graficar curvas IDA y la mediana (análisis entre 0.1g y 20g y límite de
% desplazamiento muy grande) comparar curvas de mediana de desplazamiento
n_franjas = 200;                                                            % Cantidad de franjas para interpolación de IM (0.1g hasta el máximo del "escalamiento" del registro)
for i = 1:n_modelos
    % Interpolación
    for n = 1:Data(i).nGM
        EDP_rmm = rmmissing(Data(i).EDP(:,n));
        IM_rmm = rmmissing(Data(i).IM(:,n));
        Data(i).IM_interp1(:,n) = linspace(0.1,max(Data(i).IM(:,n)),n_franjas); % g
        Data(i).EDP_interp1(:,n) = interp1(IM_rmm,EDP_rmm,Data(i).IM_interp1(:,n),'linear','extrap');
%         Data(i).EDP_interp1(:,n) = interp1(Data(i).IM(:,n),Data(i).EDP(:,n),Data(i).IM_interp1(:,n),'linear','extrap');
%         Data(i).EDP_interp1_pchip(:,n) = interp1(Data(i).IM(:,n),Data(i).EDP(:,n),Data(i).IM_interp1(:,n),'pchip');
    end

    % Distribución
%     EDP_stdln = std(log(Data(i).EDP_interp1.'));                           % Sin dispersión porq no me da razonable, IDKW
    Data(i).EDP_median(:,1) = geomean(Data(i).EDP_interp1.','omitnan').';                  % Creo que no es necesario omitnan ahora ya que interpolamos con rmmissing
    
    % Figura
    figure
    plot(Data(i).EDP,Data(i).IM,'.-','color','#606060')
    hold on
%     plot(Data(i).EDP_interp1,Data(i).IM_interp1,'color','#606060');
    plot(Data(i).EDP_median(:,1),Data(i).IM_interp1(:,1),'color','r','LineWidth',2)
%     plot(exp(log(EDP_median.')+EDP_stdln.'),Data(i).IM_interp1(:,1),'REPLACE_WITH_DASH_DASH','color','r','LineWidth',2)
%     plot(exp(log(EDP_median.')-EDP_stdln.'),Data(i).IM_interp1(:,1),'REPLACE_WITH_DASH_DASH','color','r','LineWidth',2)
    hold off
    xlabel('EDP: desplazamiento latereal [m]')
    ylabel('IM: Sa(T_1) [g]')
    title('Curvas IDA', ResultsFilesString(i))
    grid on
    legend(['Curvas IDA'; convertStringsToChars(repmat(string( ),Data(i).nGM-1,1));'Mediana'])
end

% % Todas las medianas juntas
% figure
% plot(Data.EDP_median,Data.IM_interp1(:,1))
% xlabel('EDP: Desplazamiento [m]')
% ylabel('IM: Sa(T_1) [g]')
% title('Medianas')

% Separadas por estructura
for i = 1:cant_estructuras
    figure
    hold on
    for j = 1:cant_variantes
        plot(Data((i-1)*cant_variantes+j).EDP_median,Data((i-1)*cant_variantes+j).IM_interp1(:,1))
    end
    hold off
    xlabel('EDP: Desplazamiento [m]')
    ylabel('IM: Sa(T_1) [g]')
    title('Medianas')
    legend(A{:,i})
    grid on
end


 %% P2 SIN INTERPOLAR
% for i = 1:n_ests
%    Data(i).EDP_median2(:,1) = geomean(Data(i).EDP.','omitnan').';                  % Creo que no es necesario omitnan ahora ya que interpolamos con rmmissing
%     figure
%     plot(Data(i).EDP,Data(i).IM,'.-','color','#606060')
%     hold on
%     plot(Data(i).EDP_median2(:,1),Data(i).IM(:,14),'color','r','LineWidth',2)
%     hold off
%     xlabel('EDP: desplazamiento latereal [m]')
%     ylabel('IM: Sa(T_1) [g]')
%     title('Curvas IDA', ResultsFilesString(i))
%     grid on
%     legend(['Curvas IDA'; convertStringsToChars(repmat(string( ),cant_registros-1,1));'Mediana'])
% end
% 
% for i = 1:cant_estr
%     figure
%     hold on
%     for j = 1:cant_variantes
%         plot(Data((i-1)*cant_variantes+j).EDP_median2,Data((i-1)*cant_variantes+j).IM(:,14))
%     end
%     hold off
%     xlabel('EDP: Desplazamiento [m]')
%     ylabel('IM: Sa(T_1) [g]')
%     title('Medianas')
%     legend(A{:,i})
%     grid on
% end


%% P3
% Graficar las curvas de fragilidad de colapso para cada estructura


for i = 1:cant_estructuras     % 2
    % Datos de curva de fragilidad de colapso
    figure
    hold on
    for j = 1:cant_variantes        % 4
        Data((i-1)*cant_variantes+j).muln = mean(log(Data((i-1)*cant_variantes+j).IMc).');
        Data((i-1)*cant_variantes+j).stdln = std(log(Data((i-1)*cant_variantes+j).IMc).');
        Data((i-1)*cant_variantes+j).PC = normcdf((log(Data((i-1)*cant_variantes+j).IMc).'-Data((i-1)*cant_variantes+j).muln)./Data((i-1)*cant_variantes+j).stdln);
        % Contar
        Data((i-1)*cant_variantes+j).nj = Data(i).nGM;
        Data((i-1)*cant_variantes+j).zj = 0;
        for r = 1:length(Data((i-1)*cant_variantes+j))
            for p = 1:length(Data(i).IMc)
                if Data(i).IMc(r,1) >= max(Data(i).IM(:,p))
                    Data((i-1)*cant_variantes+j).zj = Data((i-1)*cant_variantes+j).zj + 1;
                end
            end
        end
        Data((i-1)*cant_variantes+j).fraccion = Data((i-1)*cant_variantes+j).zj/Data((i-1)*cant_variantes+j).nj;
        plot(Data((i-1)*cant_variantes+j).IMc,Data((i-1)*cant_variantes+j).PC,'o','color',Colors(j))
    end
    hold off
    xlabel('IM: Sa(T_1) [g]')
    ylabel('P(C|IM=im)')
    legend(A{:,i})
    title('Datos de Probabilidad de Colapso', stringEstructuras(i))
    grid on
    
    % Curva de fragilidad de colapso (lognormal)
    figure
    hold on
    for j = 1:cant_variantes
        frag((i-1)*cant_variantes+j).curvFrag = logncdf(IM_range, Data((i-1)*cant_variantes+j).muln,Data((i-1)*cant_variantes+j).stdln);
        plot(IM_range,frag((i-1)*cant_variantes+j).curvFrag,'color',Colors(j))
    end
    for j = 1:cant_variantes                                                % Repetí for para arreglar la leyenda
        plot(Data((i-1)*cant_variantes+j).IMc,Data((i-1)*cant_variantes+j).PC,'o','color',Colors(j))
    end
    hold off
    xlabel('IM: Sa(T_1) [g]')
    ylabel('P(C|IM=im)')
    legend(A{:,i})
    title('Curva de Fragilidad de Colapso', stringEstructuras(i))
    grid on
end


%% P4
% Nombre de archivos
USGSdataName_est1 = 'USGS_data_est1.xlsx';
USGSdataName_est2 = 'USGS_data_est2.xlsx';

% Importar matrices
USGS_est1 = readmatrix(USGSdataName_est1);
USGS_est2 = readmatrix(USGSdataName_est2);
% Como USGS_est1(end,2) = 0, lo eliminamos
USGS_est1(end,:) = []; 

hazard = struct();
hazard(1).IM = USGS_est1(:,1);
hazard(2).IM = USGS_est2(:,1);
hazard(1).lambda = USGS_est1(:,2);
hazard(2).lambda = USGS_est2(:,2);

% Gráficos
figure
loglog(USGS_est1(:,1),USGS_est1(:,2),'.-')
hold on
loglog(USGS_est2(:,1),USGS_est2(:,2),'.-')
hold off
xlabel('IM: Sa(T_1) [g]')
ylabel('Annual Frequency of Exceedence \lambda_c')
title('Hazard Curves USGS')
legend('USGS T = 3.00 [sec]','USGS T = 0.20 [sec]')
grid on

% Interpolación para generar más datos
IM_length = 100;                                                            % Cantidad de valores a interpolar
USGSinterplog_est1(:,1) = linspace(0.0025,3.28,IM_length).';                   % Mejor modificarlo a meno, si no, puede que el ajuste polinomial de Miranda salga mal
USGSinterplog_est2(:,1) = linspace(0.0025,7.3,IM_length).';                   % Los límites deben ser de la parte curva

USGSinterplog_est1(:,2) = exp(interp1(log(USGS_est1(:,1)),log(USGS_est1(:,2)),log(USGSinterplog_est1(:,1))));
USGSinterplog_est2(:,2) = exp(interp1(log(USGS_est2(:,1)),log(USGS_est2(:,2)),log(USGSinterplog_est2(:,1))));

% % Borrar NaN
USGSinterplog_est1 = rmmissing(USGSinterplog_est1);
USGSinterplog_est2 = rmmissing(USGSinterplog_est2);

% 2% en 50 años
lambda_2_50_annos = 1/2475;
IM_2_50_annos_est1 = interp1(USGSinterplog_est1(:,2),USGSinterplog_est1(:,1),lambda_2_50_annos);
IM_2_50_annos_est2 = interp1(USGSinterplog_est2(:,2),USGSinterplog_est2(:,1),lambda_2_50_annos);

% Gráficos
figure
loglog(USGSinterplog_est1(:,1),USGSinterplog_est1(:,2),'.-')
hold on
loglog(USGSinterplog_est2(:,1),USGSinterplog_est2(:,2),'.-')
loglog(IM_2_50_annos_est1,lambda_2_50_annos,'o','color','r')
loglog(IM_2_50_annos_est2,lambda_2_50_annos,'o','color','r')
text(3*10^-1,10^-4,string(IM_2_50_annos_est1))
text(3,10^-4,string(IM_2_50_annos_est2))
hold off
xlim([10^-3 10^1])
xlabel('IM: Sa(T_1) [g]')
ylabel('Annual Frequency of Exceedence \lambda_i_m')
title('Hazard Curves USGS', 'Interpolado')
legend('USGS_Interp T = 3.00 [sec]','USGS_Interp T = 0.20 [sec]','2% en 50 años (\lambda_I_M = 1/2475)')
grid on

USGS = struct();
USGS(1).interpvals = USGSinterplog_est1;                                       % primera columna son IM, segunda columna son lambda (MAF)
USGS(2).interpvals = USGSinterplog_est2;                                       % Primera columna son IM, segunda columna MAF

%% P5
% Coeficientes del ajuste polinomial
[P1,~] = polyfit(log(USGSinterplog_est1(:,1)),log(USGSinterplog_est1(:,2)),4);   % Busqueda de constantes del ajuste polinomial para estructura 1
[P2,~] = polyfit(log(USGSinterplog_est2(:,1)),log(USGSinterplog_est2(:,2)),4);   % Busqueda de constantes del ajuste polinomial para estructura 2

% Generación de los valores debido al ajuste polinomial de cuarto orden
lambda1_pf = zeros(IM_length,1);                                            % Inicializar lambda del polinomio est 1 (lambda = MAF: Mean Annual Frequency)
lambda2_pf = zeros(IM_length,1);                                            % Inicializar almbda del polinomio est 2
dldim1 = zeros(IM_length,1);                                                % Inicializar derivada
dldim2 = zeros(IM_length,1);                                                % Inicializar derivada

for i = 1:IM_length
    % Ajuste polinomial primera estructura
    im = USGS(1).interpvals(i,1);
    lambda1_pf(i) = exp(P1(5) + P1(4)*log(im) + P1(3)*log(im)^2 + P1(2)*log(im)^3 + P1(1)*log(im)^4); % Eq.3 Miranda Polinomio
    parte1 = (P1(4)+2*P1(3)*log(im)+3*P1(2)*log(im)^2+4*P1(1)*log(im)^3)/im;
    dldim1(i) = abs(parte1*exp(log(lambda1_pf(i))));                        % Se puede quitar exp(log(lambda)) y dejar solo lambda
    
    % Ajuste polinomial segunda estructura
    im = USGS(2).interpvals(i,1);
    lambda2_pf(i) = exp(P2(5) + P2(4)*log(im) + P2(3)*log(im)^2 + P2(2)*log(im)^3 + P2(1)*log(im)^4); % Eq.3 Miranda Polinomio
    parte1 = (P2(4)+2*P2(3)*log(im)+3*P2(2)*log(im)^2+4*P2(1)*log(im)^3)/im;
    dldim2(i) = abs(parte1*exp(log(lambda2_pf(i))));
end

% Esto que escribí lo tira al revés xd
% IM_vals = logspace(-3,0,IM_length).';                                       % Valores de IM para interpolar
% lambda1_pf = exp(P1(5)*ones(IM_length,1) + P1(4).*log(IM_vals) + P1(3)*log(IM_vals).^2 + P1(4)*log(IM_vals).^3 + P1(5)*log(IM_vals).^4);
% lambda2_pf = exp(P2(5)*ones(IM_length,1) + P2(4).*log(IM_vals) + P2(3)*log(IM_vals).^2 + P2(4)*log(IM_vals).^3 + P2(5)*log(IM_vals).^4);

figure
loglog(USGS_est1(:,1),USGS_est1(:,2),'.-')
hold on
loglog(USGS_est2(:,1),USGS_est2(:,2),'.-')
loglog(USGS(1).interpvals(:,1),lambda1_pf)
loglog(USGS(2).interpvals(:,1),lambda2_pf)
hold off
xlabel('IM: Sa(T_1) [g]')
ylabel('Annual Frequency of Exceedence \lambda_im (MAF)')
title('Hazard Curves USGS')
legend('USGS T = 3.00 [sec]','USGS T = 0.20 [sec]','Polinomial Fit T = 3.00 [sec]','Polyfit T = 0.20 [sec]')
grid on

figure
loglog(USGS(1).interpvals(:,1),dldim1);
hold on
loglog(USGS(2).interpvals(:,1),dldim2);
hold off
xlabel('IM: Sa(T_1) [g]')
ylabel('Derivada lambda_im')
title('Derivada De curva de Amenaza sísmica')
legend('T = 3.00 [sec]', 'T = 0.20 [Sec]')
grid on


%% P6
% Caluclar y graficar la desagregación (por IM=im) de la tasa anual media
% de colapso de las estructuras 1A y 2A, considerando los siguientes casos
% para la deriva de la curva de amenaza sísmica

%% P6 a Interpolación lineal

% Inputs iniciales
lambda_col = zeros(n_modelos,1);                                            % Lambdas de Colapso
desCol = struct();                                                          % Desagregación del colapso
mod_analizar = [1 2 3 4];                                                       % Número del modelo que se quiere analizar (primeras variantes de cada estructura)

for r = 1:length(mod_analizar)                                                  % Cantidad de curvas de amenaza (1 para cada estructura, 1 estructura es un periodo => dos estructuras)
    j = mod_analizar(r);                                                    % Número del modelo que quiero analizar
    [i,~] = find(sequence == j);                                            % Buscar qué estructura es dependiendo del número del modelo
    hazard(i).IMlineal = IM_range;
    hazard(i).lambdalineal = interp1(hazard(i).IM,hazard(i).lambda,hazard(i).IMlineal);
    hazard(i).absdiff = abs(diff(hazard(i).lambdalineal)./diff(hazard(i).IMlineal));
end

for r = 1:numel(mod_analizar)                                               % Para los modelos que quiero analizar
    j = mod_analizar(r);                                                    % Número del modelo que quiero analizar
    [i,~] = find(sequence == j);                                            % Buscar qué estructura es dependiendo del número del modelo
    figure
    % Curva de Fragilidad P(C|IM=im)
    sp1 = subplot(3,1,1);
    plot(IM_range,frag(j).curvFrag,'color','r')
    grid on

    % abs de Derivada de amenaza sísmica |dlambda_IM(IM=im)/dIM=im|
    sp2 = subplot(3,1,2);
    plot(hazard(i).IMlineal, [hazard(i).absdiff; hazard(i).absdiff(end,1)]) % Repito el último número de la derivada para que sean 70 elementos
    grid on

    % Desagregación del Riesgo de Colapso P(C|IM=im)*|dlambda_IM(IM=im)/dIM=im|
    sp3 = subplot(3,1,3);
    desCol(j).Desagregacion_lineal = frag(j).curvFrag.*[hazard(i).absdiff; hazard(i).absdiff(end,1)];
    plot(hazard(i).IMlineal,desCol(j).Desagregacion_lineal)
    grid on

    % Tasa anual media de colapso
    lambda_col(j,1) = trapz(hazard(i).IMlineal,frag(j).curvFrag.*[hazard(i).absdiff; hazard(i).absdiff(end,1)]);
    xlabel('IM = Sa(T_1)')
    ylabel(sp1,'P(C|IM=im)')
    ylabel(sp2,'|d\lambda_I_M/dIM|')
    ylabel(sp3,'P(C|IM=im)*|d\lambda_I_M/dIM|')
    sgtitle(['Desagregación Tasa Anual Media de Colapso', 'Interpolación Lineal', ResultsFilesString(j)])
end


%% P6. b Interpolación loglog

lambda_col_log = zeros(n_modelos,1);                                            % Lambdas de Colapso
for r = 1:cant_estructuras
    j = mod_analizar(r);                                                    % Número del modelo que quiero analizar
    [i,~] = find(sequence == j);                                            % Buscar qué estructura es dependiendo del número del modelo
    hazard(i).IMlog = IM_range;
    hazard(i).lambdalog =  exp(interp1(log(hazard(i).IM),log(hazard(i).lambda),log(hazard(i).IMlog)));
    hazard(i).absdifflog = abs(diff(hazard(i).lambdalog)./diff(hazard(i).IMlog));
end

for r = 1:numel(mod_analizar)                                               % Para los modelos que quiero analizar
    j = mod_analizar(r);                                                    % Número del modelo que quiero analizar
    [i,~] = find(sequence == j);                                            % Buscar qué estructura es dependiendo del número del modelo
    figure
    % Curva de Fragilidad P(C|IM=im)
    sp1 = subplot(3,1,1);
    plot(IM_range,frag(j).curvFrag,'color','r')
    grid on

    % abs de Derivada de amenaza sísmica |dlambda_IM(IM=im)/dIM=im|
    sp2 = subplot(3,1,2);
    plot(hazard(i).IMlog, [hazard(i).absdifflog; hazard(i).absdifflog(end,1)]) % Repito el último número de la derivada para que sean 70 elementos
    grid on

    % Desagregación del Riesgo de Colapso P(C|IM=im)*|dlambda_IM(IM=im)/dIM=im|
    sp3 = subplot(3,1,3);
    desCol(j).Desagregacion_log = frag(j).curvFrag.*[hazard(i).absdifflog; hazard(i).absdifflog(end,1)];
    plot(hazard(i).IMlog,desCol(j).Desagregacion_log)
    grid on

    % Tasa anual media de colapso
    lambda_col_log(j,1) = trapz(hazard(i).IMlog,frag(j).curvFrag.*[hazard(i).absdifflog; hazard(i).absdifflog(end,1)]);
    xlabel('IM = Sa(T_1)')
    ylabel(sp1,'P(C|IM=im)')
    ylabel(sp2,'|d\lambda_IM/dIM|')
    ylabel(sp3,'P(C|IM=im)*|d\lambda_IM/dIM|')
    sgtitle(['Desagregación Tasa Anual Media de Colapso','Interpolación LogLog', ResultsFilesString(j)])
end

%% P6.c Ajuste Polinomial
lambda_col_poli = zeros(n_modelos,1);

% [P1,~] = polyfit(log(hazard(1).IMlog),log(hazard(1).lambdalog),4);   % Busqueda de constantes del ajuste polinomial para estructura 1
% [P2,~] = polyfit(log(hazard(2).IMlog),log(hazard(2).lambdalog),4);   % Busqueda de constantes del ajuste polinomial para estructura 2

for r = 1:cant_estructuras
    j = mod_analizar(r);                                                    % Número del modelo que quiero analizar
    [i,~] = find(sequence == j);                                            % Buscar qué estructura es dependiendo del número del modelo
    hazard(i).IMpoli = IM_range;
    for iv = 1:length(IM_range)
        im = IM_range(iv,1);
        if i == 1
            P = P1;
        elseif i == 2
            P = P2;
        end
        hazard(i).lambdapoli(iv,1) = exp(P(5) + P(4)*log(im) + P(3)*log(im)^2 + P(2)*log(im)^3 + P(1)*log(im)^4); % Eq.3 Miranda Polinomio
        parte1 = (P(4) + 2*P(3)*log(im) + 3*P(2)*log(im)^2 + 4*P(1)*log(im)^3)/im;
        hazard(i).absdiffpoli(iv,1) = abs(parte1*exp(log(hazard(i).lambdapoli(iv,1))));
    end
end

for r = 1:numel(mod_analizar)                                               % Para los modelos que quiero analizar
    j = mod_analizar(r);                                                    % Número del modelo que quiero analizar
    [i,~] = find(sequence == j);                                            % Buscar qué estructura es dependiendo del número del modelo
    figure
    % Curva de Fragilidad P(C|IM=im)
    sp1 = subplot(3,1,1);
    plot(IM_range,frag(j).curvFrag,'color','r')
    grid on

    % abs de Derivada de amenaza sísmica |dlambda_IM(IM=im)/dIM=im|
    sp2 = subplot(3,1,2);
    plot(hazard(i).IMpoli, hazard(i).absdiffpoli)
    grid on

    % Desagregación del Riesgo de Colapso P(C|IM=im)*|dlambda_IM(IM=im)/dIM=im|
    sp3 = subplot(3,1,3);
    desCol(j).Desagregacion_poli = frag(j).curvFrag.*hazard(i).absdiffpoli;
    plot(hazard(i).IMpoli,desCol(j).Desagregacion_poli)
    grid on

    % Tasa anual media de colapso
    lambda_col_poli(j,1) = trapz(hazard(i).IMpoli,frag(j).curvFrag.*hazard(i).absdiffpoli);
    xlabel('IM = Sa(T_1)')
    ylabel(sp1,'P(C|IM=im)')
    ylabel(sp2,'|d\lambda_IM/dIM|')
    ylabel(sp3,'P(C|IM=im)*|d\lambda_IM/dIM|')
    sgtitle(['Desagregación Tasa Anual Media de Colapso','Ajuste polinomio cuarto orden', ResultsFilesString(j)])
end


% Plot ambos juntos
% No parametrizado, a la rápida no mas

figure
plot(hazard(1).IMlineal,desCol(1).Desagregacion_lineal)
hold on
plot(hazard(1).IMlog, desCol(1).Desagregacion_log)
plot(hazard(1).IMlog, desCol(1).Desagregacion_poli)
hold off
xlabel('IM: Sa(T_1)')
ylabel('P(C|IM=im)*|d\lambda_IM/dIM|')
title(['Desagregación Tasa Anual Media de Colapso', ResultsFilesString(1)])
legend('Interpolación Lineal', 'Interpolación LogLog', 'Ajuste Polinomial Miranda')
grid on


figure
plot(hazard(2).IMlineal,desCol(5).Desagregacion_lineal)
hold on
plot(hazard(2).IMlog, desCol(5).Desagregacion_log)
plot(hazard(2).IMlog, desCol(5).Desagregacion_poli)
hold off
xlabel('IM: Sa(T_1)')
ylabel('P(C|IM=im)*|d\lambda_IM/dIM|')
title(['Desagregación Tasa Anual Media de Colapso', ResultsFilesString(5)])
legend('Interpolación Lineal', 'Interpolación LogLog', 'Ajuste Polinomial Miranda')
grid on

tabla = table();
tabla.Lineal = lambda_col;
tabla.Log = lambda_col_log;
tabla.Polyfit = lambda_col_poli;
disp(tabla)
clear tabla

% Si hay algún valor que da NaN, disminuir el rango de IM_range en el
% Input, para que los últimos valores de la amenaza sísmica no sean tan
% pequeños que la derivada se indefine.


%% Comparación entre polinomial 1A, 1B, 1C, 1D

figure
plot(hazard(1).IMlog, desCol(1).Desagregacion_poli)
hold on
plot(hazard(1).IMlog, desCol(2).Desagregacion_poli)
plot(hazard(1).IMlog, desCol(3).Desagregacion_poli)
plot(hazard(1).IMlog, desCol(4).Desagregacion_poli)
xlabel('IM: Sa(T_1)')
ylabel('P(C|IM=im)*|d\lambda_IM/dIM|')
title('Desagregación Tasa Anual Media de Colapso')
legend('1A','1B','1C','1D')
grid on
##### SOURCE END #####
--></body></html>